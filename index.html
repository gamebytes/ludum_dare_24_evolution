<html>
<head><title>LD24 entry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
body { border:0px;margin:0px;padding:0px; }
#game-canvas { width:100%; height:100%;border:0px;margin:0px;padding:0px; }
</style>
<script type="text/javascript">

var UI_inited = false;
var gl, canvas, ws, game, messages;

var grid, grid_program, grid_tex;

function gameHandler(evt) {
	var data = JSON.parse(evt.data);
	if(data.welcome) {
		game.player = data.welcome.name;
		addMessage(3,null,"hello "+game.player);
		var other_players = "";
		for(var competitor in data.welcome.other_players) {
			competitor = data.welcome.other_players[competitor];
			if(other_players.length) other_players += ", ";
			other_players += competitor;
		}
		if(other_players.length)
			other_players = "playing against: "+other_players;
		else
			other_players = "There are no other players!  Get a friend to play NOW!";
		addMessage(5,null,other_players);
	}
	if(data.joining) {
		if(!(data.joining in game.competitors)) {
			game.competitors.push(data.joining);
			addMessage(3,null,data.joining+" joins the game");
		}
	}
	if(data.leaving) {
		var idx = game.competitors.indexOf(data.leaving);
		if(-1 != idx) {
			addMessage(3,null,data.leaving+" leaves the game");
			game.competitors.splice(idx,1);
		}
	}
}

function addMessage(secs,from,text) {
	var 	f = UILabel(from? from: "system"),
		message = UIPanel([f,UILabel(text)],true);
	message.bgColour = [0.2,0.2,0.2,1];
	f.fgColour = from==game.name?[0.8,0.8,1,1]: !from? [1,0.8,0.8,1]: [0.8,1,0.8,1];
	messages.tree.addChild(message);
	setTimeout(function() { message.destroy(); },secs*1000);
}

function inited() {
	messages = UIWindow(false,UIPanel([],false,UILayoutRows));
	messages.show();
	game = {
		competitors:[],
	};
	var ws_path = "ws://"+window.location.href.split("/")[2]+"/ws-ld24";
	ws = new WebSocket(ws_path);
	ws.onopen = function() {
		console.log("websocket",ws_path,"open");
	};
	ws.onclose = function() {
		console.log("websocket",ws_path,"closed");
		game = null;
	};
	ws.onerror = function(e) {
		console.log("websocket",ws_path,"encountered an error:",e);
		game = null;
		ws.close();
	};
	ws.onmessage = function(evt) {
		try {
			gameHandler(evt);
		} catch(e) {
			console.log(e);
			ws.onerror(e);
		}
	};
	loadFile("image","grid.png",function(handle) {
		grid_tex = handle;
		gl.bindTexture(gl.TEXTURE_2D,grid_tex);
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT);
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT);
		gl.bindTexture(gl.TEXTURE_2D,null);
		grid = gl.createBuffer();
		initGrid(64,64,64);
	});
}

function render() {
	gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
	var zoom = 2,
		pMatrix = createPerspective(60.0,canvas.offsetWidth/canvas.offsetHeight,0.1,zoom*2),
		mvMatrix = createLookAt([zoom,zoom*0.8,zoom],[0,0,0],[0,1,0]),
		nMatrix = mat4_inverse(mat4_transpose(mvMatrix));
	if(grid) {
		gl.useProgram(grid_program);
		gl.uniformMatrix4fv(grid_program.pMatrix,false,pMatrix);
		gl.uniformMatrix4fv(grid_program.mvMatrix,false,mvMatrix);
		gl.uniformMatrix4fv(grid_program.nMatrix,false,nMatrix);
		gl.bindTexture(gl.TEXTURE_2D,grid_tex);
		gl.uniform1i(grid_program.texture,0);
		gl.bindBuffer(gl.ARRAY_BUFFER,grid);
		gl.enableVertexAttribArray(grid_program.vertex);
		gl.vertexAttribPointer(grid_program.vertex,3,gl.FLOAT,false,4*(3+3+2),0);
		gl.enableVertexAttribArray(grid_program.normal);
		gl.vertexAttribPointer(grid_program.normal,3,gl.FLOAT,false,4*(3+3+2),3*4);
		gl.enableVertexAttribArray(grid_program.texCoord);
		gl.vertexAttribPointer(grid_program.texCoord,2,gl.FLOAT,false,4*(3+3+2),(3+3)*4);
		gl.drawArrays(gl.TRIANGLES,0,2*6);
		gl.disableVertexAttribArray(grid_program.texCoord);
		gl.disableVertexAttribArray(grid_program.normal);
		gl.disableVertexAttribArray(grid_program.vertex);
		gl.bindBuffer(gl.ARRAY_BUFFER,null);
		gl.useProgram(null);
	}
	//g3d_test.draw((now()/1000)%1,pMatrix,mvMatrix,nMatrix);
}

function initGrid(w,h,d) {
	gl.bindBuffer(gl.ARRAY_BUFFER,grid);
	var 	data = new Float32Array(2*6*(3+3+2)),
		i = 0,
		addQuad = function(a,b,n,x,y) {
			var pts = [
				a[0],a[1],a[2],n[0],n[1],n[2],0,0,
				a[0],b[1],a[2],n[0],n[1],n[2],0,y,
				b[0],a[1],b[2],n[0],n[1],n[2],x,0,
				a[0],b[1],a[2],n[0],n[1],n[2],0,y,
				b[0],b[1],b[2],n[0],n[1],n[2],x,y,
				b[0],a[1],b[2],n[0],n[1],n[2],x,0,
			];
			for(var pt in pts) data[i++] = pts[pt]; 
		};
	addQuad([-1,-1,-1],[-1,1,1],[-1,0,0],d,h);
	addQuad([1,-1,-1],[1,1,1],[1,0,0],d,h);
	gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW);
	if(!grid_program) {
		grid_program = createProgram(
			"precision mediump float;\n"+
			"varying vec3 lighting;\n"+
			"varying vec2 texel;\n"+
			"attribute vec3 vertex;\n"+
			"attribute vec3 normal;\n"+
			"attribute vec2 texCoord;\n"+
			"uniform float lerp;\n"+
			"uniform mat4 mvMatrix, pMatrix, nMatrix;\n"+
			"void main() {\n"+
			"	texel = vec2(texCoord.x,texCoord.y);\n"+
			"	gl_Position = pMatrix * mvMatrix * vec4(vertex,1.0);\n"+
			"	vec3 ambientLight = vec3(0.6,0.6,0.6);\n"+
			"	vec3 lightColour = vec3(0.8,0.9,0.75);\n"+
			"	vec3 lightDir = vec3(0.85,0.8,0.75);\n"+
			"	vec3 transformed = normalize(nMatrix * vec4(normal,1.0)).xyz;\n"+
			"	float directional = clamp(dot(transformed,lightDir),0.0,1.0);\n"+
			"	lighting = ambientLight + (lightColour*directional);\n"+
			"}\n",
			"precision mediump float;\n"+
			"varying vec3 lighting;\n"+
			"varying vec2 texel;\n"+
			"uniform sampler2D texture;\n"+
			"uniform vec4 teamColour;\n"+
			"void main() {\n"+
			"	vec4 tex = texture2D(texture,texel);\n"+
			"	gl_FragColor = vec4(tex.rgb*lighting,tex.a);\n"+
			"}\n");
		grid_program.vertex = gl.getAttribLocation(grid_program,"vertex");
		grid_program.normal = gl.getAttribLocation(grid_program,"normal");
		grid_program.texCoord = gl.getAttribLocation(grid_program,"texCoord");
		grid_program.mvMatrix = gl.getUniformLocation(grid_program,"mvMatrix");
		grid_program.pMatrix = gl.getUniformLocation(grid_program,"pMatrix");
		grid_program.nMatrix = gl.getUniformLocation(grid_program,"nMatrix");
		grid_program.texture = gl.getUniformLocation(grid_program,"texture");
	}
}

function init() {
	canvas = document.getElementById("game-canvas");
	try {
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
	} catch(e) {
		console.log("Error initializing webGL:",e);
	}
	if(!gl) {
		console.log(gl);
		alert("Unable to initialize WebGL. Your browser may not support it.");
		return;
	}
  	window.onresize = function() {
		canvas.width = canvas.offsetWidth;
		canvas.height = canvas.offsetHeight;
		gl.viewport(0,0,canvas.offsetWidth,canvas.offsetHeight);
	};
	window.onresize();
	var keys = [],
		onMouseDown = function(evt) {
			evt.cancelBubble = true;
			if(!onMouseDownUI(evt))
				window.onMouseDown(evt,keys);
		},
		onMouseUp = function(evt) {
		},
		onKeyDown = function(evt) {
		},
		onKeyUp = function(evt) {
		};
	var loaded = function() {
		if(_loading.length) return;
		document.addEventListener("mousedown",onMouseDown,true);
		document.addEventListener("mouseup",onMouseUp,true);
		document.addEventListener("keydown",onKeyDown,true);
		document.addEventListener("keyup",onKeyUp,true);
		window.requestAnimFrame(loop);
		inited();
	};
	loadFile("javascript","glutil.js",loaded);
	loadFile("javascript","ui.js",loaded);
	loadFile("javascript","g3d.js",loaded);
}

function onMouseDown(evt,keys) { // you implement this!
	console.log("got",evt,keys);
} 

function onMouseUp(evt,keys) {} // you implement this!

function onKeyDown(evt,keys) {} // you implement this!

function onKeyUp(evt,keys) {} // you implement this!

function isUndefined(o) { return typeof(o) == 'undefined'; }

function now() { return (new Date()).getTime(); }

function loop() {
	window.requestAnimFrame(loop);
	render();
	drawUI(canvas);
}

var _loading = [], _loading_wait = null;

function loadFile(type,path,callback) {
	console.log("loading",type,path,"...");
	if(_loading_wait) clearTimeout(_loading_wait);
	_loading_wait = setTimeout(function() {
		alert("it's taking a long time to load all the files!  Maybe something is wrong?");
		console.log("awaiting load of:",_loading);
		},3000);
	var done = function(arg) {
		console.log("loaded",type,path,_loading);
		_loading.splice(_loading.indexOf(path),1);
		if(!_loading.length) clearTimeout(_loading_wait);
		if(callback)
			callback(arg);
		callback = null;
	};
	if(type == "javascript") {
		_loading.push(path);
		var script = document.createElement('script');
		script.setAttribute("type","text/javascript");
		script.setAttribute("src",path);
		script.async = true;
		script.onload = function() {
			if(!script.readyState || script.readyState == "loaded" || script.readyState == "complete")
				done(script);
			else
				console.log("loading state:",type,path,script.readyState);
		};
		document.getElementsByTagName("head")[0].appendChild(script);
	} else if(type == "image") {
		var image = new Image();
		image.onload = function() {
			done(createTexture(null,null,image));
		};
		image.src = path;
	} else if(type == "xml") {
		var doc = new XMLHttpRequest();
		doc.open("GET",path,true);
		doc.onreadystatechange = function() {
			if (doc.readyState==4 && (!doc.status || doc.status==200))
				done(doc.responseXML);
		};
		doc.send();
	} else if(type == "ArrayBuffer") {
		var doc = new XMLHttpRequest();
		doc.open("GET",path,true);
		doc.responseType = "arraybuffer";
		doc.overrideMimeType('text/plain; charset=x-user-defined');
		doc.onreadystatechange = function() {
			if (doc.readyState==4 && (!doc.status || doc.status==200))
				done(doc.response);
		};
		doc.send();
	} else
		console.log("unsupported type",type,path);
}

window.requestAnimFrame = 
	window.requestAnimationFrame ||
	window.webkitRequestAnimationFrame ||
	window.mozRequestAnimationFrame ||
	window.oRequestAnimationFrame ||
	window.msRequestAnimationFrame ||
	function(callback) {
		window.setTimeout(callback, 1/60);
	};
</script>
<body onload="init()">
<noscript>
Sorry, you don't have Javascript enabled :(
</noscript>
<canvas id="game-canvas">
Sorry, you don't have webGL enabled :(
</canvas>
</body>
</html>
